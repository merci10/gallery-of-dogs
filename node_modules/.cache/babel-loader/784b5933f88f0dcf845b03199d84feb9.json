{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PERSISTENCY_KEY = void 0;\n\nconst set_cookie_parser_1 = require(\"set-cookie-parser\");\n\nexports.PERSISTENCY_KEY = 'MSW_COOKIE_STORE';\nconst SUPPORTS_LOCAL_STORAGE = typeof localStorage !== 'undefined';\n\nclass CookieStore {\n  constructor() {\n    this.store = new Map();\n  }\n  /**\n   * Sets the given request cookies into the store.\n   * Respects the `request.credentials` policy.\n   */\n\n\n  add(request, response) {\n    if (request.credentials === 'omit') {\n      return;\n    }\n\n    const requestUrl = new URL(request.url);\n    const responseCookies = response.headers.get('set-cookie');\n\n    if (!responseCookies) {\n      return;\n    }\n\n    const now = Date.now();\n    const parsedResponseCookies = set_cookie_parser_1.parse(responseCookies).map(_a => {\n      var {\n        maxAge\n      } = _a,\n          cookie = __rest(_a, [\"maxAge\"]);\n\n      return Object.assign(Object.assign({}, cookie), {\n        expires: maxAge === undefined ? cookie.expires : new Date(now + maxAge * 1000),\n        maxAge\n      });\n    });\n    const prevCookies = this.store.get(requestUrl.origin) || new Map();\n    parsedResponseCookies.forEach(cookie => {\n      this.store.set(requestUrl.origin, prevCookies.set(cookie.name, cookie));\n    });\n  }\n  /**\n   * Returns cookies relevant to the given request\n   * and its `request.credentials` policy.\n   */\n\n\n  get(request) {\n    this.deleteExpiredCookies();\n    const requestUrl = new URL(request.url);\n    const originCookies = this.store.get(requestUrl.origin) || new Map();\n\n    switch (request.credentials) {\n      case 'include':\n        {\n          const documentCookies = set_cookie_parser_1.parse(document.cookie);\n          documentCookies.forEach(cookie => {\n            originCookies.set(cookie.name, cookie);\n          });\n          return originCookies;\n        }\n\n      case 'same-origin':\n        {\n          return originCookies;\n        }\n\n      default:\n        return new Map();\n    }\n  }\n  /**\n   * Returns a collection of all stored cookies.\n   */\n\n\n  getAll() {\n    this.deleteExpiredCookies();\n    return this.store;\n  }\n  /**\n   * Deletes all cookies associated with the given request.\n   */\n\n\n  deleteAll(request) {\n    const requestUrl = new URL(request.url);\n    this.store.delete(requestUrl.origin);\n  }\n  /**\n   * Clears the entire cookie store.\n   */\n\n\n  clear() {\n    this.store.clear();\n  }\n  /**\n   * Hydrates the virtual cookie store from the `localStorage` if defined.\n   */\n\n\n  hydrate() {\n    if (!SUPPORTS_LOCAL_STORAGE) {\n      return;\n    }\n\n    const persistedCookies = localStorage.getItem(exports.PERSISTENCY_KEY);\n\n    if (persistedCookies) {\n      try {\n        const parsedCookies = JSON.parse(persistedCookies);\n        parsedCookies.forEach(_ref => {\n          let [origin, cookies] = _ref;\n          this.store.set(origin, new Map(cookies.map(_a => {\n            var [token, _b] = _a,\n                {\n              expires\n            } = _b,\n                cookie = __rest(_b, [\"expires\"]);\n\n            return [token, expires === undefined ? cookie : Object.assign(Object.assign({}, cookie), {\n              expires: new Date(expires)\n            })];\n          })));\n        });\n      } catch (error) {\n        console.warn(`\n[virtual-cookie] Failed to parse a stored cookie from the localStorage (key \"${exports.PERSISTENCY_KEY}\").\n\nStored value:\n${localStorage.getItem(exports.PERSISTENCY_KEY)}\n\nThrown exception:\n${error}\n\nInvalid value has been removed from localStorage to prevent subsequent failed parsing attempts.`);\n        localStorage.removeItem(exports.PERSISTENCY_KEY);\n      }\n    }\n  }\n  /**\n   * Persists the current virtual cookies into the `localStorage` if defined,\n   * so they are available on the next page load.\n   */\n\n\n  persist() {\n    if (!SUPPORTS_LOCAL_STORAGE) {\n      return;\n    }\n\n    const serializedCookies = Array.from(this.store.entries()).map(_ref2 => {\n      let [origin, cookies] = _ref2;\n      return [origin, Array.from(cookies.entries())];\n    });\n    localStorage.setItem(exports.PERSISTENCY_KEY, JSON.stringify(serializedCookies));\n  }\n\n  deleteExpiredCookies() {\n    const now = Date.now();\n    this.store.forEach((originCookies, origin) => {\n      originCookies.forEach(_ref3 => {\n        let {\n          expires,\n          name\n        } = _ref3;\n\n        if (expires !== undefined && expires.getTime() <= now) {\n          originCookies.delete(name);\n        }\n      });\n\n      if (originCookies.size === 0) {\n        this.store.delete(origin);\n      }\n    });\n  }\n\n}\n\nexports.default = new CookieStore();","map":{"version":3,"sources":["/Users/yumakawaguchi/workspace/react-practice/gallery-of-dogs/node_modules/@mswjs/cookies/lib/CookieStore.js"],"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","defineProperty","exports","value","PERSISTENCY_KEY","set_cookie_parser_1","require","SUPPORTS_LOCAL_STORAGE","localStorage","CookieStore","constructor","store","Map","add","request","response","credentials","requestUrl","URL","url","responseCookies","headers","get","now","Date","parsedResponseCookies","parse","map","_a","maxAge","cookie","assign","expires","undefined","prevCookies","origin","forEach","set","name","deleteExpiredCookies","originCookies","documentCookies","document","getAll","deleteAll","delete","clear","hydrate","persistedCookies","getItem","parsedCookies","JSON","cookies","token","_b","error","console","warn","removeItem","persist","serializedCookies","Array","from","entries","setItem","stringify","getTime","size","default"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PERSISTENCY_KEY = void 0;\nconst set_cookie_parser_1 = require(\"set-cookie-parser\");\nexports.PERSISTENCY_KEY = 'MSW_COOKIE_STORE';\nconst SUPPORTS_LOCAL_STORAGE = typeof localStorage !== 'undefined';\nclass CookieStore {\n    constructor() {\n        this.store = new Map();\n    }\n    /**\n     * Sets the given request cookies into the store.\n     * Respects the `request.credentials` policy.\n     */\n    add(request, response) {\n        if (request.credentials === 'omit') {\n            return;\n        }\n        const requestUrl = new URL(request.url);\n        const responseCookies = response.headers.get('set-cookie');\n        if (!responseCookies) {\n            return;\n        }\n        const now = Date.now();\n        const parsedResponseCookies = set_cookie_parser_1.parse(responseCookies).map((_a) => {\n            var { maxAge } = _a, cookie = __rest(_a, [\"maxAge\"]);\n            return (Object.assign(Object.assign({}, cookie), { expires: maxAge === undefined ? cookie.expires : new Date(now + maxAge * 1000), maxAge }));\n        });\n        const prevCookies = this.store.get(requestUrl.origin) || new Map();\n        parsedResponseCookies.forEach((cookie) => {\n            this.store.set(requestUrl.origin, prevCookies.set(cookie.name, cookie));\n        });\n    }\n    /**\n     * Returns cookies relevant to the given request\n     * and its `request.credentials` policy.\n     */\n    get(request) {\n        this.deleteExpiredCookies();\n        const requestUrl = new URL(request.url);\n        const originCookies = this.store.get(requestUrl.origin) || new Map();\n        switch (request.credentials) {\n            case 'include': {\n                const documentCookies = set_cookie_parser_1.parse(document.cookie);\n                documentCookies.forEach((cookie) => {\n                    originCookies.set(cookie.name, cookie);\n                });\n                return originCookies;\n            }\n            case 'same-origin': {\n                return originCookies;\n            }\n            default:\n                return new Map();\n        }\n    }\n    /**\n     * Returns a collection of all stored cookies.\n     */\n    getAll() {\n        this.deleteExpiredCookies();\n        return this.store;\n    }\n    /**\n     * Deletes all cookies associated with the given request.\n     */\n    deleteAll(request) {\n        const requestUrl = new URL(request.url);\n        this.store.delete(requestUrl.origin);\n    }\n    /**\n     * Clears the entire cookie store.\n     */\n    clear() {\n        this.store.clear();\n    }\n    /**\n     * Hydrates the virtual cookie store from the `localStorage` if defined.\n     */\n    hydrate() {\n        if (!SUPPORTS_LOCAL_STORAGE) {\n            return;\n        }\n        const persistedCookies = localStorage.getItem(exports.PERSISTENCY_KEY);\n        if (persistedCookies) {\n            try {\n                const parsedCookies = JSON.parse(persistedCookies);\n                parsedCookies.forEach(([origin, cookies]) => {\n                    this.store.set(origin, new Map(cookies.map((_a) => {\n                        var [token, _b] = _a, { expires } = _b, cookie = __rest(_b, [\"expires\"]);\n                        return [\n                            token,\n                            expires === undefined\n                                ? cookie\n                                : Object.assign(Object.assign({}, cookie), { expires: new Date(expires) }),\n                        ];\n                    })));\n                });\n            }\n            catch (error) {\n                console.warn(`\n[virtual-cookie] Failed to parse a stored cookie from the localStorage (key \"${exports.PERSISTENCY_KEY}\").\n\nStored value:\n${localStorage.getItem(exports.PERSISTENCY_KEY)}\n\nThrown exception:\n${error}\n\nInvalid value has been removed from localStorage to prevent subsequent failed parsing attempts.`);\n                localStorage.removeItem(exports.PERSISTENCY_KEY);\n            }\n        }\n    }\n    /**\n     * Persists the current virtual cookies into the `localStorage` if defined,\n     * so they are available on the next page load.\n     */\n    persist() {\n        if (!SUPPORTS_LOCAL_STORAGE) {\n            return;\n        }\n        const serializedCookies = Array.from(this.store.entries()).map(([origin, cookies]) => {\n            return [origin, Array.from(cookies.entries())];\n        });\n        localStorage.setItem(exports.PERSISTENCY_KEY, JSON.stringify(serializedCookies));\n    }\n    deleteExpiredCookies() {\n        const now = Date.now();\n        this.store.forEach((originCookies, origin) => {\n            originCookies.forEach(({ expires, name }) => {\n                if (expires !== undefined && expires.getTime() <= now) {\n                    originCookies.delete(name);\n                }\n            });\n            if (originCookies.size === 0) {\n                this.store.delete(origin);\n            }\n        });\n    }\n}\nexports.default = new CookieStore();\n"]},"metadata":{},"sourceType":"script"}